// +build ignore

//go:generate go run gen.go
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"strings"
)

// parseFile reads a whole file into memory
// and returns a slice of its lines.
func parseFile(path string) ([]string, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var lines []string
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	return lines, scanner.Err()
}

func main() {
	tags, err := parseFile("tags.txt")
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	var buf bytes.Buffer
	fmt.Fprint(&buf, "// Code generated by go generate gen.go DO NOT EDIT.\n\n")
	fmt.Fprint(&buf, "//go:generate go run gen.go\n\n")
	fmt.Fprint(&buf, "package tag\n\n")
	fmt.Fprint(&buf, "type Tag string\n\n")
	fmt.Fprint(&buf, "func (t Tag) String() string { return string(t) }\n\n")

	fmt.Fprint(&buf, "const (\n")
	for _, tag := range tags {
		fmt.Fprintf(&buf, "\t%s\tTag = \"%s\"\n", strings.Title(tag), tag)
	}
	fmt.Fprint(&buf, "\tUnknown\tTag = \"\"\n)")

	b, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if err := ioutil.WriteFile("tags.go", b, 0644); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
